# 2022年清华大学计算机专业基础综合(912)预测卷(3)

### 数据结构

一、判断题
1. RPN中各操作数的相对次序,与原中缀表达式完全一致。
答案: 对

2. 左式堆当中,左子堆的规模和高度必然大于等于右子堆?
答案: 错
解析:
空节点路径长度 ◇引入所有的外部节点
• 消除一度节点
• 转为真二叉树 ◇Null Path Length
• npl(NULL)=0
• npl(x)=1+min{npl(1c(x)),npl(πc(x))} ◇验证: npl(x) = x到外部节点的最近距离 = 以为根的最大满子树的高度

3. 先序遍历序列和后序遍历序列可以确定唯一的真二叉树。
答案: 对
解析:
[先序+后序]×真!

4. 仅借助 GS[]表的BM算法在最好情况下只需要 O(∣T∣/∣P∣)=O(n/m) 时间。
答案: 对
解析:
aaaaacaaaaacaaaaacaaaaacaaaaab aaaaab

5. 将n个词条逐个插入一个容量为M、采用线性试探策略、初始为空的散列表,n<M,则无论它们的插入次序如何,最终的平均成功查找长度都必然一样。
答案: 对

6. 红黑树的插入和删除操作,都有可能导致(lgn)个节点的颜色反转。
答案: 对

7. 相对于KMP算法而言, BM算法更适合于大字符集的应用场合。
答案: 对

8. B-树中非叶节点中的关键码的直接后继一定来自某个叶节点。
答案: 对

9. 就地算法就是不额外申请空间的算法。
答案: 错

10. 由2019个无差别节点构成的真二叉树,与由1009对括号构成的合法表达式一样多。
答案: 对
解析:
2019个节点的真二叉树有1010个叶节点,而1010个叶节点的真二叉树的种类是Catalan (1009)

二、选择题
1. 如果将二叉树中满足"x.size<=x.parent.size/2"的非根节点x称作"轻节点",那么在包含2019个节点的二叉树中,一个节点至多可能有( )个轻的真祖先。
选项:
A. 9
B. 10
C. 11
D. 8
E. 7
答案: A
解析:
比如这个左下角的1,的轻祖先有3个,2,4都是它的轻的真祖先 所以我们尽量保证,左子树比右子树的规模少1,满足不了就让它们规模相当。 奇数减1除以2,偶数直接除2 2019, 1009, 504, 252, 126, 63, 31, 15, 7, 3, 1 1是最下面的叶结点, 轻的真祖先,3, 7, 15, 31, 63, 126, 252, 504, 1009一共9个

2. 任给12个互异的整数,且其中10个已组织为一个有序序列,现需要插入剩余的两个以完成整体排序,若采用基于比较的算法(CBA),最坏情况下至少需要做几次比较?
选项:
A. 6
B. 7
C. 8
D. 9
E. 10

3. 下图是一棵刚做过BST的下列几种操作,但尚未旋转调整的AVL树。可能的操作有()种?
选项:
I. delete (2) II. insert (3) III. delete (4) IV. insert (5) V. insert (8)
A. 1
B. 2
C. 3
D. 4

4. 2019个节点构成的二叉树做层次遍历,辅助队列容量为( )就足够了?
选项:
A. 1008
B. 1009
C. 1010
D. 1011

三、解答题
1. 对以下时间复杂度进行排序,注意可能出现相等(不考虑常系数的不同)的情况。 lg(lg∗n) 2lg∗n (2)lg n n2 n! (lgn)! (23)n n3 lg2n lg(n!) 22n n1gn1 lglgn lg∗n n⋅2n n⋅lglgn lgn 1 2lg n (lg n)lg n en 22lg n 4lgn (n+1)! lg n lg∗(lg n) n 2n nlgn 22n+1

2. 考查表达式求值算法。算法执行过程中的某时刻,若操作符栈中的括号多达2010个,则此时栈的规模(含栈底的'\0')至多可能多大?试说明理由,并示意性地画出当时栈中的内容。
解析:
【解析】 10′, +', '*', '^', '(', ' ', '*', '^',..., '(', ' ', '*', '^','!' 8040+1+1+3=8045

3. 对以下整型向量做就地排序,试给出堆初始化(Floyd算法)以及各次迭代之后向量的内容
解析:
| Rank | 0 | 1 | 2 |
| :--- | :--- | :--- | :--- |
| Vector | 16 | 2011 | 6 |
| Heap | 16 | 2011 | 6 |
| 1 | 16 | 6 | 2011 |
| 2 | 16 | 6 | 2011 |
| 3 | 16 | 6 | 2011 |

4. 可以用多叉堆去优化PFS算法的原因是什么?m叉堆的m如何选取?时间复杂度如何?
解析:
如此, PFS的运行时间将是: n⋅d⋅logdn+e⋅logdn=(n⋅d+e)⋅logdn 取 d≈e/n+2 时 总体性能达到最优: O(e⋅log(e/n+2)n) 对于稀疏图保持高效: e⋅log(e/n+2)n≈n⋅log(n/n+2)n=O(n log n) 对于稠密图改进极大: e⋅log(e/n+2)n≈n2⋅log(n2/n+2)n≈n2=O(e) 对于一般的图,会自适应地实现最优

5. 证明(请同时给出示意图) 在由n个节点构成的二叉树中,任意节点和之间的距离取作二者之间那条唯一通路的长度,记作 ∣vivj∣∣. 试证明:若二叉树的先序遍历序列为{ v0,v1,v2⋅⋅⋅,vn−1},则有: $_{k=0}^{n-1}||v_{k}v_{(k+1)mod~n}||={||v_{0}v_{1}||+||v_{1}v_{2}||++||v_{n-2}v_{n-1}||+||v_{n-1}v_{0}||=2(n-1)$
解析:
归纳法: 假设 成立 ∑k=0n−2∣∣vkv(k+1)modn∣∣=∣∣v0v1∣∣+∣∣v1v2∣∣+⋅⋅⋅+∣∣vn−3vn−2∣∣+∣∣vn−2v0∣∣=2(n−2)∣ ∑k=0n−1∣∣vkv(k+1)modn∣∣=∑k=0n−2∣∣vkv(k+1)modn∣∣+∣∣vn−2vn−1∣∣+∣∣vn−1v0∣∣−∣∣vn−2v0∣∣ =2(n−2)+∣∣vn−2vn−1∣∣+∣∣vn−1v0∣∣−∣∣vn−2v0∣∣ =2(n−2)+2 =2(n−1) vn−2 和 vn−1 是兄弟关系时候 ∣∣vn−2vn−1∣∣=2, ∣∣vn−2v0∣∣=∣∣vn−1v0∣∣ vn−2 和 vn−1 是父子关系时候|| ∣vn−2vn−1∣∣=1, ∣∣vn−2v0∣∣+1=∣∣vn−1v0∣∣ 当 n=2 时候,一共2个点,显然成立 故结论成立。

四、算法题
1. 各像素或黑或白的图像,也称作位图;正方形的位图,可用四叉树来表示和存储 其节点可定义如下:
```
struct QuadNode {
 bool black; //若是叶节点,则非黑即白;对于内部节点,无意义 [cite: 151]
 QuadNode* child[4]; //按象限排序 [cite: 152]
 QuadNode(boolb) //按指定颜色创建叶节点 [cite: 153]
 { black = b; for (int i=0; i < 4; i++) child[i] = NULL; } [cite: 154]
};
```
(子)位图与(子)四叉树的对应规则为:
• 如果位图中的所有像素同色,则对应于一个该颜色的QuadNode
• 否则,将该位图平均划分为4块子位图(依次对应于四个象限),分别对应于一棵子四叉树

A)试画出如下中间那幅位图所对应的四叉树(内部节点用×标识,黑、白叶节点分别用1、0标识):

B)试完成如下算法(关键之处需注释说明;伪代码即可,不必拘泥于C++的语法细节;如有必要,可补充子程序)
```
QuadNode*XOR (QuadNode* A, QuadNode*B); [cite: 190]
//A, B为大小相同的两幅位图对应的四叉树,试计算出二者的叠合位图所对应的四叉树 [cite: 191]
//所谓叠合,即两幅位图中对应的像素分别做一次异或运算(如上的中图,即为左图、右图的叠合) [cite: 192]
```
答案:
A) 见上图

B)
```
bool isLeaf (QuadNode* A) { [cite: 229]
 // 检查是否所有子节点都为NULL，以此判断是否为叶节点 [cite: 154, 231]
 if (A->child[0] == NULL && A->child[1] == NULL && A->child[2] == NULL && A->child [3] == NULL) { [cite: 231]
 return true;
 }
 return false;
}

QuadNode*XOR (QuadNode* A, QuadNode*B) { [cite: 194, 196]
 if (isLeaf(A) && isLeaf(B)) { // 1. A和B都是叶节点 [cite: 195]
 // 直接返回 A 和 B 颜色异或后的新叶节点
 return new QuadNode (A->black ^ B->black); [cite: 198]
 }
 else if (isLeaf(A) && !isLeaf(B)) { // 2. A是叶节点, B是内部节点 [cite: 200]
 // A需要被当作一个与其同色的、B的子树大小相同的四叉树来处理
 // C 是新创建的内部节点, 颜色无意义 [cite: 202]
 QuadNode* C = new QuadNode(false);
 for(int i=0; i<4; i++) { [cite: 204]
 // A 与 B 的每个孩子进行异或
 C->child[i] = XOR(A, B->child[i]); [cite: 206]
 }
 return C; [cite: 208]
 }
 else if (!isLeaf(A) && isLeaf(B)) { // 3. A是内部节点, B是叶节点 [cite: 211]
 // 与情况2对称
 QuadNode*C = new QuadNode(false); [cite: 212]
 for(int i=0; i<4; i++) { [cite: 213]
 // A 的每个孩子与 B 进行异或
 C->child[i] = XOR(A->child[i], B); [cite: 215]
 }
 return C; [cite: 217]
 }
 else { // 4. A和B都是内部节点 [cite: 220]
 QuadNode* C = new QuadNode(false); [cite: 221]
 for(int i=0; i<4; i++) { [cite: 222]
 // 递归地对 A 和 B 对应的子树进行异或
 C->child[i] = XOR (A->child [i], B->child [i]); [cite: 224]
 }
 return C; [cite: 226]
 }
}
```

### 操作系统

一、判断题
1. 二次机会(时钟)页面替换算法需要读取和修改页表项中访问位才能有效实现。
答案: 对

2. 如果父进程比子进程先结束,那么子进程结束后将成为资源无法被回收的僵尸进程。
答案: 错

3. 访问频率置换算法(Frequency-based Replacement)综合采用了LRU和LFU算法用于磁盘缓存置换。
答案: 对

4. SSTF 算法具有最短的平均寻道长度。
答案: 错

二、简答题
1. 设文件索引节点中有7个地址项,其中4个地址项是直接地址索引,2个地址项是一级间接地址索引,1个地址项是二级间接地址索引,每个地址项大小为4B。若磁盘索引块和磁盘数据块大小均为256B,则可表示的单个文件最大长度是多少?
答案:
4×256B+2×4256×256B+4256×4256×256B

2. 多线程与多进程对比,优缺点是什么?
答案:
线程与进程的比较
• 进程是资源分配单位,线程是CPU调度单位
• 进程拥有一个完整的资源平台,而线程只独享指令流执行的必要资源,如寄存器和栈
• 线程具有就绪、等待和运行三种基本状态和状态间的转换关系
• 线程能减少并发执行的时间和空间开销
 • 线程的创建时间比进程短
 • 线程的终止时间比进程短
 • 同一进程内的线程切换时间比进程短
 • 由于同一进程的各线程间共享内存和文件资源,可不通过内核进行直接通信

3. 连续内存分配的FF匹配, BF匹配、WF匹配各自的优缺点是什么?
答案:
• **最先匹配(First Fit Allocation)策略**
 • 原理&实现: 空闲分区列表按地址顺序排序; 分配过程时,搜索一个合适的分区; 释放分区时,检查是否可与临近的空闲分区合并
 • 优点: 简单; 在高地址空间有大块的空闲分区
 • 缺点: 外部碎片; 分配大块时较慢
• **最佳匹配(Best Fit Allocation)策略**
 • 原理&实现: 空闲分区列表按照大小排序; 分配时,查找一个合适的分区; 释放时,查找并且合并临近的空闲分区(如果找到)
 • 优点: 大部分分配的尺寸较小时,效果很好; 可避免大的空闲分区被拆分; 可减小外部碎片的大小; 相对简单
 • 缺点: 外部碎片; 释放分区较慢; 容易产生很多无用的小碎片
• **最差匹配(Worst Fit Allocation)策略**
 • 原理&实现: 空闲分区列表按由大到小排序; 分配时,选最大的分区; 释放时,检查是否可与临近的空闲分区合并,进行可能的合并,并调整空闲分区列表顺序
 • 优点: 中等大小的分配较多时,效果最好; 避免出现太多的小碎片
 • 缺点: 释放分区较慢; 外部碎片; 容易破坏大的空闲分区,因此后续难以分配大的分区

4. 试说明描述全局和局部置换算法的不同,并分别各举出两种属于全局置换和局部置换的算法。
答案:
页面置换算法分类
• **局部页面置换算法**
 • 置换页面的选择范围仅限于当前进程占用的物理页面内
 • 举例: 最优算法、先进先出算法、最近最久未使用算法 , 时钟算法、最不常用算法
• **全局页面置换算法**
 • 置换页面的选择范围是所有可换出的物理页面
 • 举例: 工作集算法、缺页率算法

5. 进程PO和P1的共享变量定义及其初值为:
```
boolean flag[2]; [cite: 306]
int turn = 0; [cite: 307]
flag[0]=FALSE; flag[1]=FALSE; [cite: 308]
```
若进程 PO和P1访问临界资源的类C伪代码实现如下:
```
void PO() //进程 PO [cite: 310]
{
 while (TRUE) [cite: 312]
 {
 flag [0]=TRUE; turn = 1; [cite: 314]
 while (flag [1] && (turn==1)) [cite: 315]
 ; [cite: 316]
 临界区; [cite: 317]
 flag[0]=FALSE; [cite: 318]
 }
}

void Pl() //进程 P1 [cite: 321]
{
 while (TRUE) [cite: 322]
 {
 flag [1]=TRUE; turn = 0; [cite: 324]
 while (flag [0] && (turn==0)) [cite: 325]
 ;
 临界区; [cite: 326]
 flag [1]=FALSE; [cite: 327]
 }
}
```
则并发执行进程P0和P1时产生的情形是能不能保证进程互斥进入临界区,会不会出现"饥饿"现象。
答案: 能保证互斥,不会出现饥饿
解析:
此算法实现互斥的主要思想在于设置了一个turn 变量,用于进程间的互相"谦让"。一般情况下,如果进程 PO试图访问临界资源,设置flag[0]=true,表示希望访问。此时如果进程P1还未试图访问临界资源,则flag [1]在进程上一次访问完临界资源退出临界区后已设置为false。所以进程PO在执行循环判断条件时,第一个条件不满足,进程PO可以正常进入临界区,且满足互斥条件。 我们需要考虑的是两个进程同时试图访问临界资源的情况。注意turn 变量的含义:进程在试图访问时,首先设置自己的flag 变量为true,表示希望访问;但又设置turn 变量为对方的进程编号,表示"谦让",因为在循环判断条件中turn 变量不是自己编号时就循环等待。这时两个进程就会互相"谦让"一番,但是这不会造成饥饿的局面,因为turn 变量会有一个最终值,所以必定有进程可以结束循环进入临界区。实际的情况是,先作出"谦让"的进程先进入临界区,后作出"谦让"的进程则需要循环等待。其实这里可以想象为两个人进门,每个人进门前都会和对方客套一句"你走先"。如果进门时没别人,就当和空气说句废话,然后大步登门入室;如果两人同时进门,就互相请先,但各自只客套一次,所以先客套的人请完对方,就等着对方请自己,然后光明正大地进门。

6. 在一个采用虚拟页式存储的超微计算机系统中,内存为256字节。页面大小为16字节,采用二级页表结构,每个页表项占1字节,页表大小4字节。页表项组成如下:高4位为二级页表或访问页面的物理页号,低4位分别是存在位(Exist)、访问位(Read)、修改位(Write)和保留位(Reserved)。 假定当前系统中正有两个并发执行的进程,进程A的第一级页表起始地址为0xBO。整个物理内存的存储内容如下。 请描述进程A访问逻辑地址0x20、0x40和0x80的地址转换计算过程。要求写出计算过程,并给出对应的一级页表项、二级页表项和访存单元的物理地址和对应的存储内容。
答案:
| 逻辑地址 | 一级页表项 | 二级页表项 | 物理地址 | 存储内容 |
| :--- | :--- | :--- | :--- | :--- |
| 0x20 | 0x8C | 0xBA | 0xB0 | 0x8C |
| 0x40 | 0x9A | 0xAA | 0xA0 | 0x00 |
| 0x80 | 0xA9 | 0x00 | (缺页) | (缺页) |
解析:
页内偏移是4位,每个页表都有4个页表项,一级页号是2位,二级页号也是2位。 A的一级页表的起始地址为0xB0。
• **访问 0x20:**
 • 逻辑地址 0x20 = 二进制`0010 0000`。
 • L1页号 =`00`, L2页号 =`10`, 页内偏移 =`0000`。
 • L1页表项地址 = 0xB0 (base) +`00`(index) = 0xB0。
 • L1页表项内容 = 0x8C (查表[0xB0]得)。
 • 0x8C =`1000 1100`。存在位=1, 二级页表物理页号=0x8。
 • 二级页表起始地址 = 0x8* 16 = 0x80。
 • L2页表项地址 = 0x80 (base) +`10`(index) = 0x82。
 • L2页表项内容 = 0xBA (查表[0x82]得)。
 • 0xBA =`1011 1010`。存在位=1, 物理数据页号=0xB。
 • 物理地址 = (0xB *16) +`0000`(offset) = 0xB0。
 • 存储内容 = 0x8C (查表[0xB0]得)。
• **访问 0x40:**
 • 逻辑地址 0x40 = 二进制`0100 0000`。
 • L1页号 =`01`, L2页号 =`00`, 页内偏移 =`0000`。
 • L1页表项地址 = 0xB0 (base) +`01`(index) = 0xB1。
 • L1页表项内容 = 0x9A (查表[0xB1]得)。
 • 0x9A =`1001 1010`。存在位=1, 二级页表物理页号=0x9。
 • 二级页表起始地址 = 0x9* 16 = 0x90。
 • L2页表项地址 = 0x90 (base) +`00`(index) = 0x90。
 • L2页表项内容 = 0xAA (查表[0x90]得)。
 • 0xAA =`1010 1010`。存在位=1, 物理数据页号=0xA。
 • 物理地址 = (0xA *16) +`0000`(offset) = 0xA0。
 • 存储内容 = 0x00 (查表[0xA0]得)。
• **访问 0x80:**
 • 逻辑地址 0x80 = 二进制`1000 0000`。
 • L1页号 =`10`, L2页号 =`00`, 页内偏移 =`0000`。
 • L1页表项地址 = 0xB0 (base) +`10`(index) = 0xB2。
 • L1页表项内容 = 0xA9 (查表[0xB2]得)。
 • 0xA9 =`1010 1001`。存在位=1, 二级页表物理页号=0xA。
 • 二级页表起始地址 = 0xA* 16 = 0xA0。
 • L2页表项地址 = 0xA0 (base) +`00`(index) = 0xA0。
 • L2页表项内容 = 0x00 (查表[0xA0]得)。
 • 0x00 =`0000 0000`。存在位=0。
 • 缺页中断。

### 组成原理

一、判断题
1. RAID5 和RAID4 比较,检错纠错能力更高。
答案: 错

2. Cache 总容量一定的话,两路组相连组织方式的命中率不低于直接映射方式的命中率。
答案: 对

3. 指令流水中使用旁路(Forwarding)技术可减少结构冲突。
答案: 错

4. 页式虚拟存储器管理中设置TLB 可提高访问速度。
答案: 对

5. 同步传输总线使用统一的时钟来协同总线事务。
答案: 对

二、填空题
1. 假定一台计算机的显示存储器用DRAM实现,若要求显示分辨率为1024×768,颜色灰度为24位,刷新频率为85Hz,显存带宽的50%用于刷新屏幕。则需要的显存总带宽至少是 _____
答案: 1024×768 x 24 x 85 x 2 = 3060M/8=382.5MB/s

2. 某机器采用按字节寻址方式,30位虚拟地址,28位物理地址,一级页表,页面大小为16KB, Cache 采用直接相联映射,大小64KB,块大小4B。则页表大小为(__) KB, Cache 块内地址(__)位,标记位(__)位,索引位(__)位
答案: 128, 2, 12, 14

三、选择题
1. 下面有关静态存储器(SRAM) 和动态存储器(DRAM) 的叙述中,正确的是。
选项:
I. SRAM和DRAM 都是电易失性存储器
II. SRAM 和DRAM 都采用随机存取方式进行数据访问
III. SRAM 和 DRAM 都可用作 Cache
IV. SRAM 和DRAM 都需要刷新
(A) 仅 I 和 II
(B) 仅 I 和 III
(C) 仅 II 和 IV
(D) 仅 III 和 IV
答案: (A)

2. 下面的命中和缺失的组合情况,在一次访存过程中,不可能发生的是。
选项:
(A) TLB未命中,页表未命中, Cache 未命中
(B) TLB未命中,页表命中, Cache 命中
(C) TLB命中,页表命中, Cache 未命中
(D) TLB命中,页表未命中, Cache 命中
答案: (D)

四、解答题
1. 假设数据通路中各主要功能单元的操作时间如下。存储器:400ps; ALU和加法器:200ps;寄存器堆读口或写口:100ps。假设MUX、控制单元、PC、扩展器和传输线路等的延迟忽略不计,程序中指令的组成比例为:取数指令占25%;存数指令占10%; ALU运算类指令占52%;分支指令占11%;跳转指令占2%。则下面的实现方式中,哪个更快?快多少?
(1) 单周期方式,每条指令在一个固定长度的时钟周期内完成。
(2) 多周期方式,并且每类指令时钟数为:取数-5,存数-4, ALU-4,分支-3,跳转-3。
(3) 流水线方式,具体来说,每条指令分取指令、取数/译码、执行、存储器访问和写回5个阶段。假定没有结构冒险;数据冒险采用"转发"技术处理;分支延迟损失时间片为1,预测准确率为75%;不考虑异常、中断和访问失效引起的流水线阻塞。
解析:
解:CPU执行时间=指令条数×CPI×时钟周期,对于同一个程序,三种方式的指令条数都一样,因此只要比较CPI和时钟周期即可。 根据已知条件,得到各类指令实际需要的执行时间如下。
• 取数指令:取指400ps+寄存器读100ps+ALU运算200ps+取数 400ps+寄存器写 100ps = 1.2ns.
• 存数指令:取指400ps+寄存器读100ps+ALU运算200ps+存数 400ps=1.1ns.
• ALU指令:取指400ps+寄存器读100ps+ALU运算200ps+寄存器写 100ps=800ps。
• 分支指令:取指400ps+寄存器读100ps+ALU运算 200ps=700ps。
• 跳转指令:取指400ps。

(1)**单周期方式**下,时钟周期由最长的取数指令确定,为1.2ns。因此, N条指令的执行时间为**1.2N ns**.
(2)**多周期方式**下,以功能部件最长所需时间作为时钟周期,因为存储器访问操作时间最长,为400ps,所以,时钟周期为400ps。根据各类指令的频度,计算出平均时钟周期数如下。 CPI = 5×25%+4×10%+4×52%+3×11%+3×2%=4.12 所以, N条指令的执行时间为 4.12×400ps×N=1.648Nns.
(3)**流水线方式**下,流水线的时钟周期取功能部件最长所需时间为400ps。每类指令所需的时钟数如下。
• 取数指令:当发生Load-use冒险时,执行时间为2个时钟周期,否则为1个时钟周期,故平均执行时间为1.5个时钟周期。
• 存数指令、ALU指令:因为采用了"转发"机制,所以流水线不会被阻塞,故只需1个时钟周期。
• 分支指令:分支延迟损失时间片为1,因而预测错误时阻塞1个时钟周期。这样,预测成功时需1个时钟周期,预测错误时需2个时钟周期。平均约为 0.75×1+0.25×2=1.25 个时钟周期。
• 跳转指令:需等到译码阶段结束才能得到转移地址,故需2个时钟周期。 因此,平均CPI为 1.5×25%+1×10%+1×52%+1.25×11%+2×2%≈1.17. 所以, N条指令的执行时间为 1.17×400ps×N=0.468Nns.

综上所述,**流水线方式的执行速度最快**,与单周期相比,约为1.2ns/0.468ns=2.56倍;与多周期相比,约为1.648ns/0.468ns=3.52倍,都要快一倍以上。
(注: 本例中,访存操作消耗了特别长的时间,它是多周期方式和流水线方式共同的瓶颈。因为各功能段耗时不均匀,所以会导致单周期方式比多周期快的现象。)

2. 有一段程序的核心模块中有5条分支指令,该模块将会被执行成千上万次,在其中一次执行过程中,5条分支指令的实际执行情况如下(T:Taken; N: not Taken).
• 分支指令1:T-T-T.
• 分支指令2:N-N-N-N。
• 分支指令3:T-N-T-N-T-N.
• 分支指令4:T-T-T-N-T.
• 分支指令5:T-T-N-T-T-N-T. 假定各个分支指令在模块每次执行过程中实际执行情况都一样,并且动态预测时,每个分支指令都有自己的预测表项,每次执行该模块时的初始预测位都相同。请分析并给出以下几种预测方案的预测准确率。
(1) 静态预测,总是预测转移(Taken)。
(2) 静态预测,总是预测不转移(not Taken)。
(3) 一位动态预测,初始预测转移(Taken)。
(4) 二位动态预测,初始预测弱转移(Taken)。
解析:
【分析解答】 预测准确率=预测正确次数/总预测次数×100%。以下R表示正确预测次数, W表示错误预测次数。
总次数 = 3 + 4 + 6 + 5 + 7 = 25
(1) B1: R-3, W-0; B2: R-0, W-4; B3: R-3, W-3; B4: R-4, W-1; B5: R-5, W-2。
总R = 3+0+3+4+5 = 15。预测准确率 = 15/25 =**60%**。
(2) B1: R-0, W-3; B2: R-4, W-0; B3: R-3, W-3; B4: R-1, W-4; B5: R-2, W-5。
总R = 0+4+3+1+2 = 10。预测准确率 = 10/25 =**40%**。
(3) B1: R-3, W-0; B2: R-3, W-1; B3: R-1, W-5; B4: R-3, W-2; B5: R-3, W-4。
总R = 3+3+1+3+3 = 13。预测准确率 = 13/25 =**52%**。
(4) B1: R-3, W-0; B2: R-3, W-1; B3: R-3, W-3; B4: R-4, W-1; B5: R-5, W-2。
总R = 3+3+3+4+5 = 18。预测准确率 = 18/25 =**72%**。

3. 假定在一个带转发的5段流水线中执行以下MIPS程序段,则怎样调整指令序列使其性能达到最好?
```
lw $2, 100 ($6)
add $2, $2, $3
lw $3, 200 ($7)
add $6, $4, $7
sub $3, $4, $6
lw $2, 300 ($8)
beq $2, $8, loop
```
解析:
【分析解答】 因为采用"转发"技术,所以,只要对load-use 数据冒险进行指令序列调整。从上述指令序列来看,第1和第2条指令、第6和第7条指令之间存在 load-use 数据冒险,所以,可将与第2和第3条指令无关的第4条指令插入第2条指令之前;将无关的第5条指令插入第7条指令之前。调整顺序后的指令序列如下(粗体部分为变换了位置的指令)。
| | | |
| 1 | lw | $2, 100 ($6) |
|**4**|**add**|**$6, $4, $7**|
| 2 | add | $2, $2, $3 |
| 3 | lw | $3, 200 ($7) |
| 6 | lw | $2, 300 ($8) |
|**5**|**sub**|**$3, $4, $6**|
| 7 | beq | $2, $8, Loop |

### 计算机网络

一、填空题
1. PPP协议包含两个部分_____和_____
答案: 链路控制协议 LCP, 网络控制协议 NCP

2. 使用GBN协议,在一条3000公里长的T1中继线上传输64字节的帧。如果信号的传播速度为6us/公里,则序列号应该有_____位。
答案: 7
解析:
T1信道,发出去64bytes数据需花费 t1=64×8÷(1.536×106)=0.33ms 往返传播时延 RTT=2×(6×10−6s/km×3000 km)=2×18ms=36ms 确认返回之前的时间为 T=RTT+t1=36ms+0.33ms=36.33ms 此时间内可发送的帧数 n=T/t1=36.33/0.33=110 帧
窗口大小 W 至少为 110。序列号位数 k 需要满足 2k>W。
26=64 (不够), 27=128 (足够)。
因此序列号需要7位。

3. 网络传输的三种交换方式为_____,_____和_____,其中_____更具有灵活性。
答案: 电路交换, 报文交换, 分组交换, 分组交换

二、解答题
1. 一台路由器的路由表中有一下的(CIDR)表项
| 地址/掩码 | 下一跳 |
| :--- | :--- |
| 135.46.56.0/22 | 接口0 |
| 135.46.60.0/22 | 接口1 |
| 192.53.40.0/23 | 路由器1 |
| 默认 | 路由器2 |

对以下每个IP地址,请问,如果一个到达分组的目标地址为该IP地址,那么路由器该怎么办?
• 135.46.63.10
• 135.46.57.14
• 135.46.52.2
• 192.53.40.7
• 192.53.56.7
答案:
• **135.46.63.10:**/22 掩码 (255.255.252.0)。地址 & 掩码 = 135.46.60.0。匹配 135.46.60.0/22。下一跳:**接口1**。
• **135.46.57.14:**/22 掩码 (255.255.252.0)。地址 & 掩码 = 135.46.56.0。匹配 135.46.56.0/22。下一跳:**接口0**。
• **135.46.52.2:**/22 掩码 (255.255.252.0)。地址 & 掩码 = 135.46.52.0。不匹配任何/22。下一跳:**路由器2**(默认)。
• **192.53.40.7:**/23 掩码 (255.255.254.0)。地址 & 掩码 = 192.53.40.0。匹配 192.53.40.0/23。下一跳:**路由器1**。
• **192.53.56.7:**/23 掩码 (255.255.254.0)。地址 & 掩码 = 192.53.56.0。不匹配任何特定路由。下一跳:**路由器2**(默认)。

2. 一个自治系统有5个局域网,如下图所示, LAN2至LAN5上的主机数分别为91、150、3和15,该自治系统分配到的IP地址块为 30.138.118/23,试给出每个局域网的地址块(包括前级)。
答案:
分配网络前缀应先分配地址数较多的前缀。已知该自治系统分配到的IP地址块为 30.138.118/23 (30.138.118.0 ~ 30.138.119.255)。(注: 答案不唯一)
• **LAN3 (150 主机):**需要 150+1=151 个地址。27−2<151<28−2。需要8位主机号, 即 /24 掩码。
 • 分配:**30.138.118.0/24**(30.138.118.0 ~ 30.138.118.255)
• **LAN2 (91 主机):**需要 91+1=92 个地址。26−2<92<27−2。需要7位主机号, 即 /25 掩码。
 • 分配:**30.138.119.0/25**(30.138.119.0 ~ 30.138.119.127)
• **LAN5 (15 主机):**需要 15+1=16 个地址。24−2<16<25−2。需要5位主机号, 即 /27 掩码。
 • 分配:**30.138.119.192/27**(30.138.119.192 ~ 30.138.119.223)
• **LAN4 (3 主机):**需要 3+1=4 个地址。22−2<4<23−2。需要3位主机号, 即 /29 掩码。
 • 分配:**30.138.119.240/29**(30.138.119.240 ~ 30.138.119.247)
• **LAN1 (3 路由器):**需要 3+1=4 个地址 (3个路由器端口+1个网关)。22−2<4<23−2。需要3位主机号, 即 /29 掩码。
 • 分配:**30.138.119.232/29**(30.138.119.232 ~ 30.138.119.239)

3. 如图所示的网络结构, TTL=64,子网掩码均为255.255.255.0, A向E发送8B数据,使用UDP
(1) 发送方A(172.16.0.1)发送的IP数据报的: 目的MAC地址、源MAC地址、目的IP、源IP、UDP数据报长度、IP数据报(总)长度
(2) 接收方E(172.16.1.5)接收到的IP数据报的: 目的MAC地址、源MAC地址、目的IP、源IP、TTL
答案:
(1)
| 目的MAC地址 | 源MAC地址 | 目的IP | 源IP | UDP数据报长度 | IP数据报长度 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 22-22-22-00-00-00 | 11-11-11-11-11-11 | 172.16.1.5 | 172.16.0.1 | 16 | 36 |
*(解析: UDP数据8B + UDP头8B = 16B。IP数据报 16B (UDP) + IP头20B = 36B)*
(2)
| 目的MAC地址 | 源MAC地址 | 目的IP | 源IP | TTL |
| :--- | :--- | :--- | :--- | :--- |
| 55-55-55-55-55-55 | 22-22-22-11-11-11 | 172.16.1.5 | 172.16.0.1 | 63 |
*(解析: 路由器转发, TTL=64-1=63)*

4. 如下图所示,一个透明网桥连接三个局域网。网桥刚启动时,地址/端口映射表为空。请根据网络上发生的事件,填写网桥地址/端口映射表的变化过程和网桥的动作。其中,"---"表示地址/端口映射表为空或网桥没有动作。网桥的动作包括:丢弃帧、向某个局域网转发帧和洪泛帧。
答案:
| 事件 | LAN1 端口对应地址列表 | LAN2 端口对应地址列表 | LAN3 端口对应地址列表 | 网桥动作 |
| :--- | :--- | :--- | :--- | :--- |
| (初始) | --- | --- | --- | --- |
| A发给B一个帧 | A | --- | --- | 洪泛帧 (B未知) |
| B发给A一个帧 | A, B | --- | --- | 丢弃帧 (A在LAN1) |
| F广播一个帧 | A, B | --- | F | 洪泛帧 (广播) |
| E发给B一个帧 | A, B | --- | E, F | 向LAN1 转发 (B在LAN1) |
| D发给C一个帧 | A, B | D | E, F | 洪泛帧 (C未知) |
| C发给F一个帧 | A, B | C, D | E, F | 向LAN3 转发 (F在LAN3) |